<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>matscipy package &mdash; matscipy devel documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> matscipy
          </a>
              <div class="version">
                devel
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">matscipy package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-matscipy.angle_distribution">matscipy.angle_distribution module</a></li>
<li><a class="reference internal" href="#module-matscipy.atomic_strain">matscipy.atomic_strain module</a></li>
<li><a class="reference internal" href="#module-matscipy.elasticity">matscipy.elasticity module</a></li>
<li><a class="reference internal" href="#module-matscipy.hydrogenate">matscipy.hydrogenate module</a></li>
<li><a class="reference internal" href="#module-matscipy.io">matscipy.io module</a></li>
<li><a class="reference internal" href="#module-matscipy.logger">matscipy.logger module</a></li>
<li><a class="reference internal" href="#module-matscipy.neighbours">matscipy.neighbours module</a></li>
<li><a class="reference internal" href="#module-matscipy.rings">matscipy.rings module</a></li>
<li><a class="reference internal" href="#module-matscipy.socketcalc">matscipy.socketcalc module</a></li>
<li><a class="reference internal" href="#matscipy-structure-identification-module">matscipy.structure_identification module</a></li>
<li><a class="reference internal" href="#module-matscipy.surface">matscipy.surface module</a></li>
<li><a class="reference internal" href="#module-matscipy">Module contents</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">matscipy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>matscipy package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/matscipy.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="matscipy-package">
<h1>matscipy package<a class="headerlink" href="#matscipy-package" title="Permalink to this heading"></a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="matscipy.contact_mechanics.html">matscipy.contact_mechanics package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="matscipy.contact_mechanics.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.contact_mechanics.html#module-matscipy.contact_mechanics.DMT">matscipy.contact_mechanics.DMT module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.contact_mechanics.html#module-matscipy.contact_mechanics.Hertz">matscipy.contact_mechanics.Hertz module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.contact_mechanics.html#module-matscipy.contact_mechanics.JKR">matscipy.contact_mechanics.JKR module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.contact_mechanics.html#module-matscipy.contact_mechanics.greens_function">matscipy.contact_mechanics.greens_function module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.contact_mechanics.html#module-matscipy.contact_mechanics">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="matscipy.fracture_mechanics.html">matscipy.fracture_mechanics package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="matscipy.fracture_mechanics.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.fracture_mechanics.html#module-matscipy.fracture_mechanics.clusters">matscipy.fracture_mechanics.clusters module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.fracture_mechanics.html#module-matscipy.fracture_mechanics.crack">matscipy.fracture_mechanics.crack module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.fracture_mechanics.html#module-matscipy.fracture_mechanics.crackpathsel">matscipy.fracture_mechanics.crackpathsel module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.fracture_mechanics.html#module-matscipy.fracture_mechanics.energy_release">matscipy.fracture_mechanics.energy_release module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.fracture_mechanics.html#module-matscipy.fracture_mechanics.idealbrittlesolid">matscipy.fracture_mechanics.idealbrittlesolid module</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.fracture_mechanics.html#module-matscipy.fracture_mechanics">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="matscipy.calculators.html">matscipy.calculators package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="matscipy.calculators.html#packages">Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="matscipy.calculators.html#modules">Modules</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-matscipy.angle_distribution">
<span id="matscipy-angle-distribution-module"></span><h2>matscipy.angle_distribution module<a class="headerlink" href="#module-matscipy.angle_distribution" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matscipy.angle_distribution.angle_distribution">
<span class="sig-prename descclassname"><span class="pre">matscipy.angle_distribution.</span></span><span class="sig-name descname"><span class="pre">angle_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.angle_distribution.angle_distribution" title="Permalink to this definition"></a></dt>
<dd><p>Compute a bond angle distribution from a neighbour list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dr</strong> (<em>i</em><em>, </em><em>j</em><em>,</em>) – Neighbour list, including list of distance vectors.</p></li>
<li><p><strong>nbins</strong> (<em>int</em>) – Number of bins for bond angle histogram.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em><em>, </em><em>optional</em>) – Bond length cutoff, i.e. consider only bonds shorter than this length.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-matscipy.atomic_strain">
<span id="matscipy-atomic-strain-module"></span><h2>matscipy.atomic_strain module<a class="headerlink" href="#module-matscipy.atomic_strain" title="Permalink to this heading"></a></h2>
<p>Compute deformation gradient tensor and D^2_min measure for non-affine
displacements.
See: Falk, Langer, Phys. Rev. E 57, 7192 (1998)</p>
<dl class="py function">
<dt class="sig sig-object py" id="matscipy.atomic_strain.array_inverse">
<span class="sig-prename descclassname"><span class="pre">matscipy.atomic_strain.</span></span><span class="sig-name descname"><span class="pre">array_inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.atomic_strain.array_inverse" title="Permalink to this definition"></a></dt>
<dd><p>Compute inverse for each matrix in a list of matrices.
This is faster than calling numpy.linalg.inv for each matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.atomic_strain.atomic_strain">
<span class="sig-prename descclassname"><span class="pre">matscipy.atomic_strain.</span></span><span class="sig-name descname"><span class="pre">atomic_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.atomic_strain.atomic_strain" title="Permalink to this definition"></a></dt>
<dd><p>Calculate deformation gradient tensor and D^2_min measure for non-affine
displacements.
See: Falk, Langer, Phys. Rev. B 57, 7192 (1998)</p>
<dl class="simple">
<dt>atoms_now<span class="classifier">ase.Atoms</span></dt><dd><p>Current atomic configuration</p>
</dd>
<dt>atoms_old<span class="classifier">ase.Atoms</span></dt><dd><p>Reference atomic configuration</p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>Neighbor list cutoff.</p>
</dd>
<dt>neighbours<span class="classifier">( array_like, array_like )</span></dt><dd><p>Neighbor list. Automatically computed if not provided.</p>
</dd>
</dl>
<dl class="simple">
<dt>delta_plus_epsilon<span class="classifier">array</span></dt><dd><p>3x3 deformation gradient tensor for each atom.</p>
</dd>
<dt>residual<span class="classifier">array</span></dt><dd><p>D^2_min norm for each atom</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.atomic_strain.get_D_square_min">
<span class="sig-prename descclassname"><span class="pre">matscipy.atomic_strain.</span></span><span class="sig-name descname"><span class="pre">get_D_square_min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_old</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_plus_epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.atomic_strain.get_D_square_min" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the D^2_min norm of Falk and Langer</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.atomic_strain.get_XIJ">
<span class="sig-prename descclassname"><span class="pre">matscipy.atomic_strain.</span></span><span class="sig-name descname"><span class="pre">get_XIJ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr_old</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.atomic_strain.get_XIJ" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the X_{ij} matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.atomic_strain.get_YIJ">
<span class="sig-prename descclassname"><span class="pre">matscipy.atomic_strain.</span></span><span class="sig-name descname"><span class="pre">get_YIJ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr_old</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.atomic_strain.get_YIJ" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the Y_{ij} matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.atomic_strain.get_delta_plus_epsilon">
<span class="sig-prename descclassname"><span class="pre">matscipy.atomic_strain.</span></span><span class="sig-name descname"><span class="pre">get_delta_plus_epsilon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr_old</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.atomic_strain.get_delta_plus_epsilon" title="Permalink to this definition"></a></dt>
<dd><p>Calculate delta_ij+epsilon_ij, i.e. the deformation gradient matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.atomic_strain.get_delta_plus_epsilon_dgesv">
<span class="sig-prename descclassname"><span class="pre">matscipy.atomic_strain.</span></span><span class="sig-name descname"><span class="pre">get_delta_plus_epsilon_dgesv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr_now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dr_old</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.atomic_strain.get_delta_plus_epsilon_dgesv" title="Permalink to this definition"></a></dt>
<dd><p>Calculate delta_ij+epsilon_ij, i.e. the deformation gradient matrix</p>
</dd></dl>

</section>
<section id="module-matscipy.elasticity">
<span id="matscipy-elasticity-module"></span><h2>matscipy.elasticity module<a class="headerlink" href="#module-matscipy.elasticity" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="matscipy.elasticity.CubicElasticModuli">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">CubicElasticModuli</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C44</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.CubicElasticModuli" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.elasticity.CubicElasticModuli.compliance">
<span class="sig-name descname"><span class="pre">compliance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.CubicElasticModuli.compliance" title="Permalink to this definition"></a></dt>
<dd><p>Return the compliance coefficients</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.elasticity.CubicElasticModuli.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.CubicElasticModuli.rotate" title="Permalink to this definition"></a></dt>
<dd><p>Compute the rotated stiffness matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.elasticity.CubicElasticModuli.stiffness">
<span class="sig-name descname"><span class="pre">stiffness</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.CubicElasticModuli.stiffness" title="Permalink to this definition"></a></dt>
<dd><p>Return the elastic constants</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.elasticity.CubicElasticModuli.tol">
<span class="sig-name descname"><span class="pre">tol</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-06</span></em><a class="headerlink" href="#matscipy.elasticity.CubicElasticModuli.tol" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.Voigt_6_to_full_3x3_strain">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">Voigt_6_to_full_3x3_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strain_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.Voigt_6_to_full_3x3_strain" title="Permalink to this definition"></a></dt>
<dd><p>Form a 3x3 strain matrix from a 6 component vector in Voigt notation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.Voigt_6_to_full_3x3_stress">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">Voigt_6_to_full_3x3_stress</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stress_vector</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.Voigt_6_to_full_3x3_stress" title="Permalink to this definition"></a></dt>
<dd><p>Form a 3x3 stress matrix from a 6 component vector in Voigt notation</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.Voigt_6x6_to_cubic">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">Voigt_6x6_to_cubic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.Voigt_6x6_to_cubic" title="Permalink to this definition"></a></dt>
<dd><p>Convert the Voigt 6x6 representation into the cubic elastic constants
C11, C12 and C44.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.Voigt_6x6_to_full_3x3x3x3">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">Voigt_6x6_to_full_3x3x3x3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.Voigt_6x6_to_full_3x3x3x3" title="Permalink to this definition"></a></dt>
<dd><p>Convert from the Voigt representation of the stiffness matrix to the full
3x3x3x3 representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>C</strong> (<em>array_like</em>) – 6x6 stiffness matrix (Voigt notation).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>C</strong> – 3x3x3x3 stiffness matrix.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.cubic_to_Voigt_6x6">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">cubic_to_Voigt_6x6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C44</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.cubic_to_Voigt_6x6" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.elastic_moduli">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">elastic_moduli</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([1,</span> <span class="pre">0,</span> <span class="pre">0])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.elastic_moduli" title="Permalink to this definition"></a></dt>
<dd><p>Calculate elastic moduli from 6x6 elastic constant matrix C_{ij}.</p>
<p>The elastic moduli calculated are: Young’s muduli, Poisson’s ratios,
shear moduli, bulk mudulus and bulk mudulus tensor.</p>
<p>If a direction l is specified, the system is rotated to have it as its
x direction (see Notes for details). If R is specified the system is
rotated according to it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>array_like</em>) – 6x6 stiffness matrix (Voigt notation).</p></li>
<li><p><strong>l</strong> (<em>array_like</em><em>, </em><em>optional</em>) – 3D direction vector for pull (the default is the x direction
of the original system)</p></li>
<li><p><strong>R</strong> (<em>array_like</em><em>, </em><em>optional</em>) – 3x3 rotation matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>E</strong> (<em>array_like</em>) – Young’s modulus for a stress in each of the three directions
of the rotated system.</p></li>
<li><p><strong>nu</strong> (<em>array_like</em>) – 3x3 matrix with Poisson’s ratios.</p></li>
<li><p><strong>Gm</strong> (<em>array_like</em>) – 3x3 matrix with shear moduli.</p></li>
<li><p><strong>B</strong> (<em>float</em>) – Bulk modulus.</p></li>
<li><p><strong>K</strong> (<em>array_like</em>) – 3x3 matrix with bulk modulus tensor.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><p><strong>tol</strong> (<em>float, optional</em>) – tolerance for checking validity of rotation and comparison
of vectors.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It works by rotating the elastic constant tensor to the desired
direction, so it should be valid for arbitrary crystal structures.
If only l is specified there is an infinite number of possible
rotations. The chosen one is a rotation along the axis orthogonal
to the plane defined by the vectors (1, 0, 0) and l.</p>
<p>Bulk modulus tensor as defined in
O. Rand and V. Rovenski, “Analytical Methods in Anisotropic
Elasticity”, Birkh”auser (2005), pp. 71.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.fit_elastic_constants">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">fit_elastic_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'triclinic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">graphics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.fit_elastic_constants" title="Permalink to this definition"></a></dt>
<dd><p>Compute elastic constants by linear regression of stress vs. strain</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>ase.Atoms</em><em> or </em><em>list of ase.Atoms</em>) – Either a single atomic configuration or a list of strained
configurations. If a single configuration is given, it is
passed <a class="reference internal" href="#matscipy.elasticity.generate_strained_configs" title="matscipy.elasticity.generate_strained_configs"><code class="xref py py-func docutils literal notranslate"><span class="pre">generate_strained_configs()</span></code></a> along with <cite>symmetry</cite>, <cite>N_steps</cite>,
and <cite>delta</cite> to generate the set of strained configurations.</p></li>
<li><p><strong>symmetry</strong> (<em>string</em>) – Symmetry to use to determine which strain patterns are necessary.
Default is ‘triclininc’, i.e. no symmetry.</p></li>
<li><p><strong>N_steps</strong> (<em>int</em>) – Number of atomic configurations to generate for each strain pattern.
Default is 5. Absolute strain values range from -delta*N_steps/2
to +delta*N_steps/2.</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – Strain increment for analytical derivatives of stresses.
Default is 1e-2.</p></li>
<li><p><strong>optimizer</strong> (<em>ase.optimizer.*</em>) – Optimizer to use for atomic positions (internal degrees of freedom)
for each applied strain. Initial config <cite>a</cite> is not optimised, and should
already have relaxed cell and atomic positions. Does not optimize atomic
positions if set to None.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – If True, print additional infomation about the quality of fit
and summarise results of C_ij and estimated errors. Default True.</p></li>
<li><p><strong>graphics</strong> (<em>bool</em>) – If True, use <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> to plot the stress vs. strain
curve for each C_ij component fitted. Default True.</p></li>
<li><p><strong>logfile</strong> (<em>bool</em>) – Log file to write optimizer output to. Default None (i.e. suppress
output).</p></li>
<li><p><strong>**kwargs</strong> (<em>dict</em>) – Additional arguments to pass to <cite>optimizer.run()</cite> method e.g. <cite>fmax</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>C</strong> (<em>array_like</em>) – 6x6 matrix of the elastic constants in Voigt notation.</p></li>
<li><p><strong>C_err</strong> (<em>array_like</em>) – If scipy.stats module is available then error estimates for each C_ij
component are obtained from the accuracy of the linear regression.
Otherwise an array of np.zeros((6,6)) is returned.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Code originally adapted from elastics.py script, available from
<a class="reference external" href="http://github.com/djw/elastic-constants">http://github.com/djw/elastic-constants</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.full_3x3_to_Voigt_6_index">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">full_3x3_to_Voigt_6_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.full_3x3_to_Voigt_6_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.full_3x3_to_Voigt_6_strain">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">full_3x3_to_Voigt_6_strain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strain_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.full_3x3_to_Voigt_6_strain" title="Permalink to this definition"></a></dt>
<dd><p>Form a 6 component strain vector in Voigt notation from a 3x3 matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.full_3x3_to_Voigt_6_stress">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">full_3x3_to_Voigt_6_stress</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stress_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.full_3x3_to_Voigt_6_stress" title="Permalink to this definition"></a></dt>
<dd><p>Form a 6 component stress vector in Voigt notation from a 3x3 matrix</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.full_3x3x3x3_to_Voigt_6x6">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">full_3x3x3x3_to_Voigt_6x6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.full_3x3x3x3_to_Voigt_6x6" title="Permalink to this definition"></a></dt>
<dd><p>Convert from the full 3x3x3x3 representation of the stiffness matrix
to the representation in Voigt notation. Checks symmetry in that process.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.generate_strained_configs">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">generate_strained_configs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'triclinic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.generate_strained_configs" title="Permalink to this definition"></a></dt>
<dd><p>Generate a sequence of strained configurations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>ase.Atoms</em>) – Bulk crystal configuration - both unit cell and atomic positions
should be relaxed before calling this routine.</p></li>
<li><p><strong>symmetry</strong> (<em>string</em>) – Symmetry to use to determine which strain patterns are necessary.
Default is ‘triclininc’, i.e. no symmetry.</p></li>
<li><p><strong>N_steps</strong> (<em>int</em>) – Number of atomic configurations to generate for each strain pattern.
Default is 5. Absolute strain values range from -delta*N_steps/2
to +delta*N_steps/2.</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – Strain increment for analytical derivatives of stresses. Default 1e-2</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Generator which yields a sequence of ase.Atoms instances corresponding</em></p></li>
<li><p><em>to the minima set of strained conifugurations required to evaluate the</em></p></li>
<li><p><em>full 6x6 C_ij matrix under the assumed symmetry.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.invariants">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">invariants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">syy=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">szz=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">syz=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sxz=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sxy=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full_3x3_to_Voigt_6=&lt;function</span> <span class="pre">full_3x3_to_Voigt_6_stress&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.invariants" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.measure_triclinic_elastic_constants">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">measure_triclinic_elastic_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.measure_triclinic_elastic_constants" title="Permalink to this definition"></a></dt>
<dd><p>Brute-force measurement of elastic constants for a triclinic (general)
unit cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>ase.Atoms</em>) – Atomic configuration.</p></li>
<li><p><strong>optimizer</strong> (<em>ase.optimizer.*</em>) – Optimizer to use for atomic position. Does not optimize atomic
position if set to None.</p></li>
<li><p><strong>delta</strong> (<em>float</em>) – Strain increment for analytical derivatives of stresses.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>C</strong> – 6x6 matrix of the elastic constants in Voigt notation.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.nonaffine_elastic_contribution">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">nonaffine_elastic_contribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalues</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvectors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pc_parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cg_parameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'M':</span> <span class="pre">None,</span> <span class="pre">'atol':</span> <span class="pre">1e-05,</span> <span class="pre">'callback':</span> <span class="pre">None,</span> <span class="pre">'maxiter':</span> <span class="pre">None,</span> <span class="pre">'tol':</span> <span class="pre">1e-05,</span> <span class="pre">'x0':</span> <span class="pre">None}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.nonaffine_elastic_contribution" title="Permalink to this definition"></a></dt>
<dd><p>Compute the correction of non-affine displacements to the elasticity tensor.
The computation of the occuring inverse of the Hessian matrix is bypassed by
using a cg solver.</p>
<p>If eigenvalues and and eigenvectors are given the inverse of the Hessian can
be easily computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>ase.Atoms</em>) – Atomic configuration in a local or global minima.</p></li>
<li><p><strong>eigenvalues</strong> (<em>array</em>) – Eigenvalues in ascending order obtained by diagonalization of Hessian matrix.
If given, use eigenvalues and eigenvectors to compute non-affine contribution.</p></li>
<li><p><strong>eigenvectors</strong> (<em>array</em>) – Eigenvectors corresponding to eigenvalues.</p></li>
<li><p><strong>cg_parameters</strong> (<em>dict</em>) – <p>Dictonary for the conjugate-gradient solver.</p>
<dl class="simple">
<dt>x0: {array, matrix}</dt><dd><p>Starting guess for the solution.</p>
</dd>
<dt>tol/atol: float, optional</dt><dd><p>Tolerances for convergence, norm(residual) &lt;= max(tol*norm(b), atol).</p>
</dd>
<dt>maxiter: int</dt><dd><p>Maximum number of iterations. Iteration will stop after maxiter steps even if the specified tolerance has not been achieved.</p>
</dd>
<dt>M: {sparse matrix, dense matrix, LinearOperator}</dt><dd><p>Preconditioner for A.</p>
</dd>
<dt>callback: function</dt><dd><p>User-supplied function to call after each iteration.</p>
</dd>
</dl>
</p></li>
<li><p><strong>pc_parameters</strong> (<em>dict</em>) – <p>Dictonary for the incomplete LU decomposition of the Hessian.</p>
<dl class="simple">
<dt>A: array_like</dt><dd><p>Sparse matrix to factorize.</p>
</dd>
<dt>drop_tol: float</dt><dd><p>Drop tolerance for an incomplete LU decomposition.</p>
</dd>
<dt>fill_factor: float</dt><dd><p>Specifies the fill ratio upper bound.</p>
</dd>
<dt>drop_rule: str</dt><dd><p>Comma-separated string of drop rules to use.</p>
</dd>
<dt>permc_spec: str</dt><dd><p>How to permute the columns of the matrix for sparsity.</p>
</dd>
<dt>diag_pivot_thresh: float</dt><dd><p>Threshold used for a diagonal entry to be an acceptable pivot.</p>
</dd>
<dt>relax: int</dt><dd><p>Expert option for customizing the degree of relaxing supernodes.</p>
</dd>
<dt>panel_size: int</dt><dd><p>Expert option for customizing the panel size.</p>
</dd>
<dt>options: dict</dt><dd><p>Dictionary containing additional expert options to SuperLU.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.poisson_ratio">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">poisson_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.poisson_ratio" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Calculate approximate Poisson ratio</p>
</div></blockquote>
<p>u_{lm} from 6x6 elastic constant matrix C_{ij}</p>
<blockquote>
<div><p>This is the response in <cite>m</cite> direction to pulling in <cite>l</cite> direction. Result is dimensionless.</p>
<p>Formula is from W. Brantley, Calculated elastic constants for stress problems associated
with semiconductor devices. J. Appl. Phys., 44, 534 (1973).</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.rotate_cubic_elastic_constants">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">rotate_cubic_elastic_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">C44</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.rotate_cubic_elastic_constants" title="Permalink to this definition"></a></dt>
<dd><p>Return rotated elastic moduli for a cubic crystal given the elastic
constant in standard C11, C12, C44 notation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C44</strong> (<em>C11</em><em>, </em><em>C12</em><em>,</em>) – Cubic elastic moduli.</p></li>
<li><p><strong>A</strong> (<em>array_like</em>) – 3x3 rotation matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>C</strong> – 6x6 matrix of rotated elastic constants (Voigt notation).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.rotate_elastic_constants">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">rotate_elastic_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.rotate_elastic_constants" title="Permalink to this definition"></a></dt>
<dd><p>Return rotated elastic moduli for a general crystal given the elastic
constant in Voigt notation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>C</strong> (<em>array_like</em>) – 6x6 matrix of elastic constants (Voigt notation).</p></li>
<li><p><strong>A</strong> (<em>array_like</em>) – 3x3 rotation matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>C</strong> – 6x6 matrix of rotated elastic constants (Voigt notation).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.elasticity.youngs_modulus">
<span class="sig-prename descclassname"><span class="pre">matscipy.elasticity.</span></span><span class="sig-name descname"><span class="pre">youngs_modulus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">C</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.elasticity.youngs_modulus" title="Permalink to this definition"></a></dt>
<dd><p>Calculate approximate Youngs modulus E_l from 6x6 elastic constants matrix C_ij</p>
<p>This is the modulus for loading in the l direction. For the exact answer, taking
into account elastic anisotropuy, rotate the C_ij matrix to the correct frame,
compute the compliance matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># 6x6 C_ij matrix in crystal frame</span>
<span class="n">A</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># rotation matrix</span>
<span class="n">Cr</span> <span class="o">=</span> <span class="n">rotate_elastic_constants</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Cr</span><span class="p">)</span>
<span class="n">E_x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Young&#39;s modulus for a pull in x direction</span>
<span class="n">E_y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Young&#39;s modulus for a pull in y direction</span>
<span class="n">E_z</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># Young&#39;s modulus for a pull in z direction</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Formula is from W. Brantley, Calculated elastic constants for stress problems associated
with semiconductor devices. J. Appl. Phys., 44, 534 (1973).</p>
</dd></dl>

</section>
<section id="module-matscipy.hydrogenate">
<span id="matscipy-hydrogenate-module"></span><h2>matscipy.hydrogenate module<a class="headerlink" href="#module-matscipy.hydrogenate" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matscipy.hydrogenate.hydrogenate">
<span class="sig-prename descclassname"><span class="pre">matscipy.hydrogenate.</span></span><span class="sig-name descname"><span class="pre">hydrogenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bond_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[True,</span> <span class="pre">True,</span> <span class="pre">True]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vacuum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.hydrogenate.hydrogenate" title="Permalink to this definition"></a></dt>
<dd><p>Hydrogenate a slab of material at its periodic boundary conditions.
Boundary conditions are turned into nonperiodic.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>ase.Atoms</em>) – Atomic configuration.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Cutoff for neighbor counting.</p></li>
<li><p><strong>bond_length</strong> (<em>float</em>) – X-H bond length for hydrogenation.</p></li>
<li><p><strong>b</strong> (<em>ase.Atoms</em><em>, </em><em>optional</em>) – If present, this is the configuration to hydrogenate. Number of atoms
must be identical to a object. All bonds present in a but not present
in b will be hydrogenated in b.</p></li>
<li><p><strong>mask</strong> (<em>list of bool</em>) – Cartesian directions which to hydrogenate, only if b argument is not
given.</p></li>
<li><p><strong>exclude</strong> (<em>array_like</em>) – Boolean array masking atoms to be excluded from hydrogenation.</p></li>
<li><p><strong>vacuum</strong> (<em>float</em><em>, </em><em>optional</em>) – Add this much vacuum after hydrogenation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>a</strong> – Atomic configuration of the hydrogenated slab.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ase.Atoms</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-matscipy.io">
<span id="matscipy-io-module"></span><h2>matscipy.io module<a class="headerlink" href="#module-matscipy.io" title="Permalink to this heading"></a></h2>
</section>
<section id="module-matscipy.logger">
<span id="matscipy-logger-module"></span><h2>matscipy.logger module<a class="headerlink" href="#module-matscipy.logger" title="Permalink to this heading"></a></h2>
<p>Log status to screen.</p>
<dl class="py class">
<dt class="sig sig-object py" id="matscipy.logger.Logger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.logger.</span></span><span class="sig-name descname"><span class="pre">Logger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logfile=&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outevery=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sepevery=10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.flush">
<span class="sig-name descname"><span class="pre">flush</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.flush" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.get_logfile">
<span class="sig-name descname"><span class="pre">get_logfile</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.get_logfile" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.has_logfile">
<span class="sig-name descname"><span class="pre">has_logfile</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.has_logfile" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.iteration_finished">
<span class="sig-name descname"><span class="pre">iteration_finished</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.iteration_finished" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.pr">
<span class="sig-name descname"><span class="pre">pr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">caller</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.pr" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.set_logfile">
<span class="sig-name descname"><span class="pre">set_logfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.set_logfile" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.set_outevery">
<span class="sig-name descname"><span class="pre">set_outevery</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outevery</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.set_outevery" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.st">
<span class="sig-name descname"><span class="pre">st</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hdr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_print</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.st" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.logger.Logger.warn">
<span class="sig-name descname"><span class="pre">warn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">caller</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.Logger.warn" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.logger.flatten">
<span class="sig-prename descclassname"><span class="pre">matscipy.logger.</span></span><span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.flatten" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.logger.hdr_str">
<span class="sig-prename descclassname"><span class="pre">matscipy.logger.</span></span><span class="sig-name descname"><span class="pre">hdr_str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.hdr_str" title="Permalink to this definition"></a></dt>
<dd><p>Return header description strings</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.logger.hdrfmt_str">
<span class="sig-prename descclassname"><span class="pre">matscipy.logger.</span></span><span class="sig-name descname"><span class="pre">hdrfmt_str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.hdrfmt_str" title="Permalink to this definition"></a></dt>
<dd><p>Return header format string for datatype x</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.logger.numfmt_str">
<span class="sig-prename descclassname"><span class="pre">matscipy.logger.</span></span><span class="sig-name descname"><span class="pre">numfmt_str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.logger.numfmt_str" title="Permalink to this definition"></a></dt>
<dd><p>Return numeric format string for datatype x</p>
</dd></dl>

</section>
<section id="module-matscipy.neighbours">
<span id="matscipy-neighbours-module"></span><h2>matscipy.neighbours module<a class="headerlink" href="#module-matscipy.neighbours" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="matscipy.neighbours.CutoffNeighbourhood">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.neighbours.</span></span><span class="sig-name descname"><span class="pre">CutoffNeighbourhood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pair_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dict</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.CutoffNeighbourhood" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#matscipy.neighbours.Neighbourhood" title="matscipy.neighbours.Neighbourhood"><code class="xref py py-class docutils literal notranslate"><span class="pre">Neighbourhood</span></code></a></p>
<p>Class defining neighbourhood based on proximity.</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.CutoffNeighbourhood.get_pairs">
<span class="sig-name descname"><span class="pre">get_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.CutoffNeighbourhood.get_pairs" title="Permalink to this definition"></a></dt>
<dd><p>Return pairs and quantities from conventional neighbour list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.CutoffNeighbourhood.get_triplets">
<span class="sig-name descname"><span class="pre">get_triplets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.CutoffNeighbourhood.get_triplets" title="Permalink to this definition"></a></dt>
<dd><p>Return triplets and quantities from conventional neighbour list.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.neighbours.MolecularNeighbourhood">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.neighbours.</span></span><span class="sig-name descname"><span class="pre">MolecularNeighbourhood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molecules</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Molecules</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.MolecularNeighbourhood" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#matscipy.neighbours.Neighbourhood" title="matscipy.neighbours.Neighbourhood"><code class="xref py py-class docutils literal notranslate"><span class="pre">Neighbourhood</span></code></a></p>
<p>Class defining neighbourhood based on molecular connectivity.</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.MolecularNeighbourhood.complete_connectivity">
<span class="sig-name descname"><span class="pre">complete_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typeoffset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.MolecularNeighbourhood.complete_connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Add angles to pair connectivity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.MolecularNeighbourhood.double_connectivity">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">double_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#matscipy.neighbours.MolecularNeighbourhood.double_connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Sort and stack connectivity + reverse connectivity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.MolecularNeighbourhood.get_pairs">
<span class="sig-name descname"><span class="pre">get_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.MolecularNeighbourhood.get_pairs" title="Permalink to this definition"></a></dt>
<dd><p>Return pairs and quantities from connectivities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.MolecularNeighbourhood.get_triplets">
<span class="sig-name descname"><span class="pre">get_triplets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.MolecularNeighbourhood.get_triplets" title="Permalink to this definition"></a></dt>
<dd><p>Return triplets and quantities from connectivities.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.neighbours.MolecularNeighbourhood.molecules">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">molecules</span></span><a class="headerlink" href="#matscipy.neighbours.MolecularNeighbourhood.molecules" title="Permalink to this definition"></a></dt>
<dd><p>Molecules instance that defines neighbourhood.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="matscipy.neighbours.MolecularNeighbourhood.pair_types">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pair_types</span></span><a class="headerlink" href="#matscipy.neighbours.MolecularNeighbourhood.pair_types" title="Permalink to this definition"></a></dt>
<dd><p>Map atom types to pair types.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.neighbours.Neighbourhood">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.neighbours.</span></span><span class="sig-name descname"><span class="pre">Neighbourhood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.Neighbourhood" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract class defining a neighbourhood of atoms (pairs, triplets).</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.Neighbourhood.compute_distances">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compute_distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#matscipy.neighbours.Neighbourhood.compute_distances" title="Permalink to this definition"></a></dt>
<dd><p>Return distances and vectors for connectivity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.Neighbourhood.get_pairs">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.Neighbourhood.get_pairs" title="Permalink to this definition"></a></dt>
<dd><p>Return requested data on pairs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.Neighbourhood.get_triplets">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_triplets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quantities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.Neighbourhood.get_triplets" title="Permalink to this definition"></a></dt>
<dd><p>Return requested data on triplets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.neighbours.Neighbourhood.make_result">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">make_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">accepted_quantities</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span></span></span><a class="headerlink" href="#matscipy.neighbours.Neighbourhood.make_result" title="Permalink to this definition"></a></dt>
<dd><p>Construct result list.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.neighbours.find_common_neighbours">
<span class="sig-prename descclassname"><span class="pre">matscipy.neighbours.</span></span><span class="sig-name descname"><span class="pre">find_common_neighbours</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.find_common_neighbours" title="Permalink to this definition"></a></dt>
<dd><p>Find common neighbors of pairs of atoms</p>
<p>For each pair <code class="docutils literal notranslate"><span class="pre">(i1,</span> <span class="pre">j1)</span></code> in the neighbor list, find all other pairs
<code class="docutils literal notranslate"><span class="pre">(i2,</span> <span class="pre">j1)</span></code> which share the same <code class="docutils literal notranslate"><span class="pre">j1</span></code>. This includes <code class="docutils literal notranslate"><span class="pre">(i1,j1)</span></code>
itself. In this way, create a list with <code class="docutils literal notranslate"><span class="pre">n</span></code> blocks of rows, where <code class="docutils literal notranslate"><span class="pre">n</span></code>
is the length of the neighbor list. All rows in a block have the same
<code class="docutils literal notranslate"><span class="pre">j1</span></code>. Each row corresponds to one triplet <code class="docutils literal notranslate"><span class="pre">(i1,</span> <span class="pre">j1</span> <span class="pre">,i2)</span></code>. The number
of rows in the block is equal to the total number of neighbors of <code class="docutils literal notranslate"><span class="pre">j1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i_n</strong> (<em>array_like</em>) – array of atom identifiers</p></li>
<li><p><strong>j_n</strong> (<em>array_like</em>) – array of atom identifiers</p></li>
<li><p><strong>nat</strong> (<em>int</em>) – number of atoms</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cnl_i1_i2</strong> (<em>array</em>) – atom numbers i1 and i2</p></li>
<li><p><strong>cnl_j1</strong> (<em>array</em>) – shared neighbor of i1 and i2</p></li>
<li><p><strong>nl_index_i1_j1</strong> (<em>array</em>) – index in the neighbor list of pair i1, j1</p></li>
<li><p><strong>nl_index_i2_j1</strong> (<em>array</em>) – index in the neighbor list of pair i2, j1</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Accumulate random numbers for pairs with common neighbors:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matscipy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">ase.lattice.cubic</span> <span class="k">import</span> <span class="n">FaceCenteredCubic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matscipy.neighbours</span> <span class="k">import</span> <span class="n">neighbour_list</span><span class="p">,</span> <span class="n">find_common_neighbours</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cutoff</span> <span class="o">=</span> <span class="mf">6.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">FaceCenteredCubic</span><span class="p">(</span><span class="s1">&#39;Cu&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">numbers</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nat</span><span class="p">)</span>
<span class="go">256</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i_n</span><span class="p">,</span> <span class="n">j_n</span><span class="p">,</span> <span class="n">dr_nc</span><span class="p">,</span> <span class="n">abs_dr_n</span> <span class="o">=</span> <span class="n">neighbour_list</span><span class="p">(</span><span class="s1">&#39;ijDd&#39;</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i_n</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(22016,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnl_i1_i2</span><span class="p">,</span> <span class="n">cnl_j1</span><span class="p">,</span> <span class="n">nl_index_i1_j1</span><span class="p">,</span> <span class="n">nl_index_i2_j1</span> <span class="o">=</span> <span class="n">find_common_neighbours</span><span class="p">(</span><span class="n">i_n</span><span class="p">,</span> <span class="n">j_n</span><span class="p">,</span> <span class="n">nat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnl_i1_i2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(1893376, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unique_pairs_i1_i2</span><span class="p">,</span> <span class="n">bincount_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cnl_i1_i2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">unique_pairs_i1_i2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(65536, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">cnl_i1_i2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">bincount_bins</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">tmp</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">unique_pairs_i1_i2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">my_sum</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(65536,)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.neighbours.find_indices_of_reversed_pairs">
<span class="sig-prename descclassname"><span class="pre">matscipy.neighbours.</span></span><span class="sig-name descname"><span class="pre">find_indices_of_reversed_pairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_dr_n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.find_indices_of_reversed_pairs" title="Permalink to this definition"></a></dt>
<dd><p>Find neighbor list indices where reversed pairs are stored</p>
<p>Given list of identifiers of neighbor atoms <cite>i_n</cite> and <cite>j_n</cite>,
determines the list of indices <cite>reverse</cite> into the neighbor list
where each pair is reversed, i.e. <cite>i_n[reverse[n]]=j_n[n]</cite> and
<cite>j_n[reverse[n]]=i_n[n]</cite> for each index <cite>n</cite> in the neighbor list</p>
<p>In the case of small periodic systems, one needs to be careful, because
the same pair may appear more than one time, with different pair
distances. Therefore, the pair distance must be taken into account.</p>
<p>We assume that there is in fact one reversed pair for every pair.
However, we do not check this assumption in order to avoid overhead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i_n</strong> (<em>array_like</em>) – array of atom identifiers</p></li>
<li><p><strong>j_n</strong> (<em>array_like</em>) – array of atom identifiers</p></li>
<li><p><strong>abs_dr_n</strong> (<em>array_like</em>) – pair distances</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>reverse</strong> – array of indices into i_n and j_n</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.neighbours.mic">
<span class="sig-prename descclassname"><span class="pre">matscipy.neighbours.</span></span><span class="sig-name descname"><span class="pre">mic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.mic" title="Permalink to this definition"></a></dt>
<dd><p>Apply minimum image convention to an array of distance vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dr</strong> (<em>array_like</em>) – Array of distance vectors.</p></li>
<li><p><strong>cell</strong> (<em>array_like</em>) – Simulation cell.</p></li>
<li><p><strong>pbc</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Periodic boundary conditions in x-, y- and z-direction. Default is to
assume periodic boundaries in all directions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>dr</strong> – Array of distance vectors, wrapped according to the minimum image
convention.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.neighbours.neighbour_list">
<span class="sig-prename descclassname"><span class="pre">matscipy.neighbours.</span></span><span class="sig-name descname"><span class="pre">neighbour_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">positions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numbers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.neighbour_list" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Compute a neighbor list for an atomic configuration. Atoms outside periodic
boundaries are mapped into the box. Atoms outside nonperiodic boundaries
are included in the neighbor list but the complexity of neighbor list search
for those can become n^2.</p>
<p>The neighbor list is sorted by first atom index ‘i’, but not by second
atom index ‘j’.</p>
<p>The neighbour list accepts either an ASE Atoms object or positions and cell
vectors individually.</p>
<dl>
<dt>quantities<span class="classifier">str</span></dt><dd><p>Quantities to compute by the neighbor list algorithm. Each character
in this string defines a quantity. They are returned in a tuple of
the same order. Possible quantities are</p>
<blockquote>
<div><p>‘i’ : first atom index
‘j’ : second atom index
‘d’ : absolute distance
‘D’ : distance vector
‘S’ : shift vector (number of cell boundaries crossed by the bond</p>
<blockquote>
<div><p>between atom i and j). With the shift vector S, the
distances D between atoms can be computed from:
D = a.positions[j]-a.positions[i]+S.dot(a.cell)</p>
</div></blockquote>
</div></blockquote>
</dd>
<dt>atoms<span class="classifier">ase.Atoms</span></dt><dd><p>Atomic configuration. (Default: None)</p>
</dd>
<dt>cutoff<span class="classifier">float or dict</span></dt><dd><dl class="simple">
<dt>Cutoff for neighbor search. It can be</dt><dd><ul class="simple">
<li><p>A single float: This is a global cutoff for all elements.</p></li>
<li><p>A dictionary: This specifies cutoff values for element
pairs. Specification accepts element numbers of symbols.
Example: {(1, 6): 1.1, (1, 1): 1.0, (‘C’, ‘C’): 1.85}</p></li>
<li><p>A list/array with a per atom value: This specifies the radius of
an atomic sphere for each atoms. If spheres overlap, atoms are
within each others neighborhood.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>positions<span class="classifier">array_like</span></dt><dd><p>Atomic positions. (Default: None)</p>
</dd>
<dt>cell<span class="classifier">array_like</span></dt><dd><p>Cell vectors as a 3x3 matrix. (Default: Shrink wrapped cell)</p>
</dd>
<dt>pbc<span class="classifier">array_like</span></dt><dd><p>3-vector containing periodic boundary conditions in all three
directions. (Default: Nonperiodic box)</p>
</dd>
<dt>numbers<span class="classifier">array_like</span></dt><dd><p>Array containing the atomic numbers.</p>
</dd>
</dl>
<dl class="simple">
<dt>i, j, …<span class="classifier">array</span></dt><dd><p>Tuple with arrays for each quantity specified above. Indices in <cite>i</cite>
are returned in ascending order 0..len(a), but the order of (i,j)
pairs is not guaranteed.</p>
</dd>
</dl>
<p>Examples assume Atoms object <em>a</em> and numpy imported as <em>np</em>.
1. Coordination counting:</p>
<blockquote>
<div><p>i = neighbor_list(‘i’, a, 1.85)
coord = np.bincount(i)</p>
</div></blockquote>
<ol class="arabic" start="2">
<li><dl>
<dt>Coordination counting with different cutoffs for each pair of species</dt><dd><dl class="simple">
<dt>i = neighbor_list(‘i’, a,</dt><dd><p>{(‘H’, ‘H’): 1.1, (‘C’, ‘H’): 1.3, (‘C’, ‘C’): 1.85})</p>
</dd>
</dl>
<p>coord = np.bincount(i)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Pair distribution function:</dt><dd><p>d = neighbor_list(‘d’, a, 10.00)
h, bin_edges = np.histogram(d, bins=100)
pdf = h/(4*np.pi/3*(bin_edges[1:]**3 - bin_edges[:-1]**3)) * a.get_volume()/len(a)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Pair potential:</dt><dd><p>i, j, d, D = neighbor_list(‘ijdD’, a, 5.0)
energy = (-C/d**6).sum()
pair_forces = (6*C/d**5  * (D/d).T).T
forces_x = np.bincount(j, weights=pair_forces[:, 0], minlength=len(a)) -                    np.bincount(i, weights=pair_forces[:, 0], minlength=len(a))
forces_y = np.bincount(j, weights=pair_forces[:, 1], minlength=len(a)) -                    np.bincount(i, weights=pair_forces[:, 1], minlength=len(a))
forces_z = np.bincount(j, weights=pair_forces[:, 2], minlength=len(a)) -                    np.bincount(i, weights=pair_forces[:, 2], minlength=len(a))</p>
</dd>
</dl>
</li>
<li><dl>
<dt>Dynamical matrix for a pair potential stored in a block sparse format:</dt><dd><p>from scipy.sparse import bsr_matrix
i, j, dr, abs_dr = neighbor_list(‘ijDd’, atoms)
energy = (dr.T / abs_dr).T
dynmat = -(dde * (energy.reshape(-1, 3, 1) * energy.reshape(-1, 1, 3)).T).T                  -(de / abs_dr * (np.eye(3, dtype=energy.dtype) -                    (energy.reshape(-1, 3, 1) * energy.reshape(-1, 1, 3))).T).T
dynmat_bsr = bsr_matrix((dynmat, j, first_i), shape=(3*len(a), 3*len(a)))</p>
<p>dynmat_diag = np.empty((len(a), 3, 3))
for x in range(3):</p>
<blockquote>
<div><dl class="simple">
<dt>for y in range(3):</dt><dd><p>dynmat_diag[:, x, y] = -np.bincount(i, weights=dynmat[:, x, y])</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>dynmat_bsr += bsr_matrix((dynmat_diag, np.arange(len(a)),</dt><dd><blockquote>
<div><p>np.arange(len(a) + 1)),</p>
</div></blockquote>
<p>shape=(3 * len(a), 3 * len(a)))</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<p>i_n, j_n, dr_nc, abs_dr_n = neighbour_list(‘ijDd’, atoms, dict)</p>
</div></blockquote>
<dl>
<dt>e_nc = (dr_nc.T/abs_dr_n).T</dt><dd><p>D_ncc = -(dde_n * (e_nc.reshape(-1,3,1) * e_nc.reshape(-1,1,3)).T).T
D_ncc += -(de_n/abs_dr_n * (np.eye(3, dtype=e_nc.dtype) - (e_nc.reshape(-1,3,1) * e_nc.reshape(-1,1,3))).T).T</p>
<p>D = bsr_matrix((D_ncc, j_n, first_i), shape=(3*nat,3*nat))</p>
<p>Ddiag_icc = np.empty((nat,3,3))
for x in range(3):</p>
<blockquote>
<div><dl class="simple">
<dt>for y in range(3):</dt><dd><p>Ddiag_icc[:,x,y] = -np.bincount(i_n, weights = D_ncc[:,x,y])</p>
</dd>
</dl>
</div></blockquote>
<p>D += bsr_matrix((Ddiag_icc,np.arange(nat),np.arange(nat+1)), shape=(3*nat,3*nat))</p>
<p>return D</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.neighbours.triplet_list">
<span class="sig-prename descclassname"><span class="pre">matscipy.neighbours.</span></span><span class="sig-name descname"><span class="pre">triplet_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first_neighbours</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_dr_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j_p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.neighbours.triplet_list" title="Permalink to this definition"></a></dt>
<dd><p>Compute a triplet list for an atomic configuration. The triple list is a
mask that can be applied to the corresponding neighbour list to mask
triplet properties.
The triplet list accepts an first_neighbour array (generated by
first_neighbours) as input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>first_neighbours</strong> (<em>array</em>) – adresses of the first time an atom occours in the neighour list</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ij_t, ik_t</strong> (<em>array</em>) – lists of adresses that form triples in the pair lists</p></li>
<li><p><strong>jk_t</strong> (<em>array (if and only if i_p, j_p, first_i != None)</em>) – list of pairs jk that connect each triplet ij, ik
between atom j and k</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>i_n, j_n, abs_dr_p = neighbour_list(‘ijd’, atoms=atoms, cutoff=cutoff)</p>
<p>first_i = np.array([0, 2, 6, 10], dtype=’int32’)
a = triplet_list(first_i, [2.2]*9+[3.0], 2.6)</p>
<p># one may obtain first_ij by using
find_ij = first_neighbours(len(i_p), ij_t)
# or (slower but less parameters and more general,
# i.e for every ordered list)
first_ij = get_jump_indicies(ij_t)</p>
</dd></dl>

</section>
<section id="module-matscipy.rings">
<span id="matscipy-rings-module"></span><h2>matscipy.rings module<a class="headerlink" href="#module-matscipy.rings" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matscipy.rings.ring_statistics">
<span class="sig-prename descclassname"><span class="pre">matscipy.rings.</span></span><span class="sig-name descname"><span class="pre">ring_statistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxlength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.rings.ring_statistics" title="Permalink to this definition"></a></dt>
<dd><p>Compute number of shortest path rings in sample.
See: D.S. Franzblau, Phys. Rev. B 44, 4925 (1991)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>ase.Atoms</em>) – Atomic configuration.</p></li>
<li><p><strong>cutoff</strong> (<em>float</em>) – Cutoff for neighbor counting.</p></li>
<li><p><strong>maxlength</strong> (<em>float</em><em>, </em><em>optional</em>) – Maximum ring length. Search for rings will stop at this length. This
is useful to speed up calculations for large systems.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>ringstat</strong> – Array with number of shortest path rings.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-matscipy.socketcalc">
<span id="matscipy-socketcalc-module"></span><h2>matscipy.socketcalc module<a class="headerlink" href="#module-matscipy.socketcalc" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsRequestHandler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">AtomsRequestHandler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">request</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">client_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">server</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsRequestHandler" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRequestHandler</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsRequestHandler.handle">
<span class="sig-name descname"><span class="pre">handle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsRequestHandler.handle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServer">
<span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">AtomsServer</span></span><a class="headerlink" href="#matscipy.socketcalc.AtomsServer" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#matscipy.socketcalc.AtomsServerAsync" title="matscipy.socketcalc.AtomsServerAsync"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomsServerAsync</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerAsync">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">AtomsServerAsync</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">server_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RequestHandlerClass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bind_and_activate=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_attempts=3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgq=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerAsync" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#matscipy.socketcalc.AtomsServerSync" title="matscipy.socketcalc.AtomsServerSync"><code class="xref py py-class docutils literal notranslate"><span class="pre">AtomsServerSync</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ThreadingMixIn</span></code></p>
<p>Asynchronous (threaded) version of AtomsServer</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerAsync.shutdown">
<span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerAsync.shutdown" title="Permalink to this definition"></a></dt>
<dd><p>Stops the serve_forever loop.</p>
<p>Blocks until the loop has finished. This must be called while
serve_forever() is running in another thread, or it will
deadlock.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerAsync.shutdown_clients">
<span class="sig-name descname"><span class="pre">shutdown_clients</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerAsync.shutdown_clients" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerSync">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">AtomsServerSync</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">server_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RequestHandlerClass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clients</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bind_and_activate=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_attempts=3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgq=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerSync" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TCPServer</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerSync.allow_reuse_address">
<span class="sig-name descname"><span class="pre">allow_reuse_address</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#matscipy.socketcalc.AtomsServerSync.allow_reuse_address" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerSync.get_results">
<span class="sig-name descname"><span class="pre">get_results</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerSync.get_results" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerSync.join_all">
<span class="sig-name descname"><span class="pre">join_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerSync.join_all" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerSync.put">
<span class="sig-name descname"><span class="pre">put</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">client_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_restart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerSync.put" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerSync.server_activate">
<span class="sig-name descname"><span class="pre">server_activate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerSync.server_activate" title="Permalink to this definition"></a></dt>
<dd><p>Called by constructor to activate the server.</p>
<p>May be overridden.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerSync.shutdown">
<span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerSync.shutdown" title="Permalink to this definition"></a></dt>
<dd><p>Stops the serve_forever loop.</p>
<p>Blocks until the loop has finished. This must be called while
serve_forever() is running in another thread, or it will
deadlock.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.AtomsServerSync.shutdown_clients">
<span class="sig-name descname"><span class="pre">shutdown_clients</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.AtomsServerSync.shutdown_clients" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.CastepClient">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">CastepClient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">client_id,</span> <span class="pre">exe,</span> <span class="pre">env=None,</span> <span class="pre">npj=1,</span> <span class="pre">ppn=1,</span> <span class="pre">block=None,</span> <span class="pre">corner=None,</span> <span class="pre">shape=None,</span> <span class="pre">jobname='socketcalc',</span> <span class="pre">rundir=None,</span> <span class="pre">fmt='REFTRAJ',</span> <span class="pre">parmode=None,</span> <span class="pre">mpirun='mpirun',</span> <span class="pre">mpirun_args=['-np'],</span> <span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;,</span> <span class="pre">max_pos_diff=1.0,</span> <span class="pre">max_cell_diff=1.0,</span> <span class="pre">**castep_args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.CastepClient" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#matscipy.socketcalc.QMClient" title="matscipy.socketcalc.QMClient"><code class="xref py py-class docutils literal notranslate"><span class="pre">QMClient</span></code></a></p>
<p>Subclass of Client for running CASTEP calculations.</p>
<p>Initial input files are written in .cell and .param
formats, and subsequent communication is via sockets in REFTRAJ format.</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.CastepClient.extra_args">
<span class="sig-name descname"><span class="pre">extra_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.CastepClient.extra_args" title="Permalink to this definition"></a></dt>
<dd><p>Return list of additional command line arguments to be passed to client</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.CastepClient.postprocess">
<span class="sig-name descname"><span class="pre">postprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.CastepClient.postprocess" title="Permalink to this definition"></a></dt>
<dd><p>Post-process results of calculation.</p>
<p>May be overrriden in subclasses to e.g. reverse sort order
applied in preprocess().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.CastepClient.preprocess">
<span class="sig-name descname"><span class="pre">preprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_restart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.CastepClient.preprocess" title="Permalink to this definition"></a></dt>
<dd><p>Prepare client for a calculation.</p>
<p>Starts client if this is the first task for it, or schedules a
restart if new configuration is not compatible with the last
one submitted to the queue (see is_compatible() method).</p>
<p>Many be extended in subclasses to e.g. sort the atoms by
atomic number. If Atoms object needs to be changed, a copy
should be returned rather than updating it inplace.</p>
<p>Returns (at, first_time).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.CastepClient.write_input_files">
<span class="sig-name descname"><span class="pre">write_input_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.CastepClient.write_input_files" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">Client</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">client_id,</span> <span class="pre">exe,</span> <span class="pre">env=None,</span> <span class="pre">npj=1,</span> <span class="pre">ppn=1,</span> <span class="pre">block=None,</span> <span class="pre">corner=None,</span> <span class="pre">shape=None,</span> <span class="pre">jobname='socketcalc',</span> <span class="pre">rundir=None,</span> <span class="pre">fmt='REFTRAJ',</span> <span class="pre">parmode=None,</span> <span class="pre">mpirun='mpirun',</span> <span class="pre">mpirun_args=['-np'],</span> <span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;,</span> <span class="pre">max_pos_diff=1.0,</span> <span class="pre">max_cell_diff=0.001</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Represents a single Client job</p>
<p>Used by AtomsServer to start, restart and shutdown clients
running on the Compute Nodes.</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.extra_args">
<span class="sig-name descname"><span class="pre">extra_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.extra_args" title="Permalink to this definition"></a></dt>
<dd><p>Return list of additional command line arguments to be passed to client</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.is_compatible">
<span class="sig-name descname"><span class="pre">is_compatible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old_at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.is_compatible" title="Permalink to this definition"></a></dt>
<dd><p>Check if new_at and old_at are compatible.</p>
<p>Returns True if calculation can be continued, or False
if client must be restarted before it can process new_at.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.postprocess">
<span class="sig-name descname"><span class="pre">postprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.postprocess" title="Permalink to this definition"></a></dt>
<dd><p>Post-process results of calculation.</p>
<p>May be overrriden in subclasses to e.g. reverse sort order
applied in preprocess().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.preprocess">
<span class="sig-name descname"><span class="pre">preprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_restart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.preprocess" title="Permalink to this definition"></a></dt>
<dd><p>Prepare client for a calculation.</p>
<p>Starts client if this is the first task for it, or schedules a
restart if new configuration is not compatible with the last
one submitted to the queue (see is_compatible() method).</p>
<p>Many be extended in subclasses to e.g. sort the atoms by
atomic number. If Atoms object needs to be changed, a copy
should be returned rather than updating it inplace.</p>
<p>Returns (at, first_time).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.shutdown">
<span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.shutdown" title="Permalink to this definition"></a></dt>
<dd><p>Request a client to shutdown.</p>
<p>If block=True, does not return until shutdown is complete.  If
block=False, waits for the client to shutdown in a new
thread. Check self.waits_thread.isAlive() to see when shutdown
has finished. (This function also returns a handle to the wait
thread when block=False).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.start" title="Permalink to this definition"></a></dt>
<dd><p>Start an individual client.</p>
<p>Raises RuntimeError if this client is already running.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.start_or_restart">
<span class="sig-name descname"><span class="pre">start_or_restart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.start_or_restart" title="Permalink to this definition"></a></dt>
<dd><p>Start or restart a client</p>
<p>If restart=True, wait for previous client to shutdown first.
Calls write_input_files() followed by start().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.wait_for_shutdown">
<span class="sig-name descname"><span class="pre">wait_for_shutdown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.wait_for_shutdown" title="Permalink to this definition"></a></dt>
<dd><p>Block until a client has shutdown.</p>
<p>Typically called automatically by shutdown() or
start_or_restart().</p>
<p>Shutdown should previously have been initiated by queuing a
‘shutdown’ or ‘restart’ request. Waits CLIENT_TIMEOUT for
graceful shutdown. If client is still alive, a SIGTERM signal
is sent. If this has had no effect after a further
CLIENT_TIMEOUT, then a SIGKILL is sent. Does not return until
the SIGKILL has taken effect.</p>
<p>This function also marks shutdown task as complete in
servers’s input_q for this client.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.Client.write_input_files">
<span class="sig-name descname"><span class="pre">write_input_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.Client.write_input_files" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.QMClient">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">QMClient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">client_id,</span> <span class="pre">exe,</span> <span class="pre">env=None,</span> <span class="pre">npj=1,</span> <span class="pre">ppn=1,</span> <span class="pre">block=None,</span> <span class="pre">corner=None,</span> <span class="pre">shape=None,</span> <span class="pre">jobname='socketcalc',</span> <span class="pre">rundir=None,</span> <span class="pre">fmt='REFTRAJ',</span> <span class="pre">parmode=None,</span> <span class="pre">mpirun='mpirun',</span> <span class="pre">mpirun_args=['-np'],</span> <span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;,</span> <span class="pre">max_pos_diff=1.0,</span> <span class="pre">max_cell_diff=0.001</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.QMClient" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#matscipy.socketcalc.Client" title="matscipy.socketcalc.Client"><code class="xref py py-class docutils literal notranslate"><span class="pre">Client</span></code></a></p>
<p>Abstract subclass of Client for QM calculations</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.QMClient.is_compatible">
<span class="sig-name descname"><span class="pre">is_compatible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">old_at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.QMClient.is_compatible" title="Permalink to this definition"></a></dt>
<dd><p>Check if new_at and old_at are compatible.</p>
<p>Returns True if calculation can be continued, or False
if client must be restarted before it can process new_at.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.QUIPClient">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">QUIPClient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">client_id,</span> <span class="pre">exe,</span> <span class="pre">env=None,</span> <span class="pre">npj=1,</span> <span class="pre">ppn=1,</span> <span class="pre">block=None,</span> <span class="pre">corner=None,</span> <span class="pre">shape=None,</span> <span class="pre">jobname='socketcalc',</span> <span class="pre">rundir=None,</span> <span class="pre">fmt='REFTRAJ',</span> <span class="pre">parmode=None,</span> <span class="pre">mpirun='mpirun',</span> <span class="pre">mpirun_args=['-np'],</span> <span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;,</span> <span class="pre">max_pos_diff=1.0,</span> <span class="pre">max_cell_diff=0.001,</span> <span class="pre">param_files=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.QUIPClient" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#matscipy.socketcalc.Client" title="matscipy.socketcalc.Client"><code class="xref py py-class docutils literal notranslate"><span class="pre">Client</span></code></a></p>
<p>Subclass of Client for running QUIP calculations.</p>
<p>Initial input files are written in extended XYZ format, and
subsequent communication is via sockets, in either REFTRAJ
or XYZ format.</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.QUIPClient.write_input_files">
<span class="sig-name descname"><span class="pre">write_input_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.QUIPClient.write_input_files" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.SocketCalculator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">SocketCalculator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">client</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">port=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgq=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.SocketCalculator" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Calculator</span></code></p>
<p>ASE-compatible calculator which communicates with remote
force engines via sockets using a (synchronous) AtomsServer.</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.SocketCalculator.calculate">
<span class="sig-name descname"><span class="pre">calculate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">properties</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system_changes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.SocketCalculator.calculate" title="Permalink to this definition"></a></dt>
<dd><p>Do the calculation.</p>
<dl class="simple">
<dt>properties: list of str</dt><dd><p>List of what needs to be calculated.  Can be any combination
of ‘energy’, ‘forces’, ‘stress’, ‘dipole’, ‘charges’, ‘magmom’
and ‘magmoms’.</p>
</dd>
<dt>system_changes: list of str</dt><dd><p>List of what has changed since last calculation.  Can be
any combination of these six: ‘positions’, ‘numbers’, ‘cell’,
‘pbc’, ‘initial_charges’ and ‘initial_magmoms’.</p>
</dd>
</dl>
<p>Subclasses need to implement this, but can ignore properties
and system_changes if they want.  Calculated properties should
be inserted into results dictionary like shown in this dummy
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;energy&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="s1">&#39;forces&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">)),</span>
                <span class="s1">&#39;stress&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
                <span class="s1">&#39;dipole&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                <span class="s1">&#39;charges&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)),</span>
                <span class="s1">&#39;magmom&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                <span class="s1">&#39;magmoms&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">))}</span>
</pre></div>
</div>
<p>The subclass implementation should first call this
implementation to set the atoms attribute and create any missing
directories.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.socketcalc.SocketCalculator.default_parameters">
<span class="sig-name descname"><span class="pre">default_parameters</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#matscipy.socketcalc.SocketCalculator.default_parameters" title="Permalink to this definition"></a></dt>
<dd><p>Default parameters</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.socketcalc.SocketCalculator.implemented_properties">
<span class="sig-name descname"><span class="pre">implemented_properties</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['energy',</span> <span class="pre">'forces',</span> <span class="pre">'stress']</span></em><a class="headerlink" href="#matscipy.socketcalc.SocketCalculator.implemented_properties" title="Permalink to this definition"></a></dt>
<dd><p>Properties calculator can handle (energy, forces, …)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.socketcalc.SocketCalculator.name">
<span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'SocketCalculator'</span></em><a class="headerlink" href="#matscipy.socketcalc.SocketCalculator.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.SocketCalculator.shutdown">
<span class="sig-name descname"><span class="pre">shutdown</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.SocketCalculator.shutdown" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.socketcalc.VaspClient">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">VaspClient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">client_id,</span> <span class="pre">exe,</span> <span class="pre">env=None,</span> <span class="pre">npj=1,</span> <span class="pre">ppn=1,</span> <span class="pre">block=None,</span> <span class="pre">corner=None,</span> <span class="pre">shape=None,</span> <span class="pre">jobname='socketcalc',</span> <span class="pre">rundir=None,</span> <span class="pre">fmt='REFTRAJ',</span> <span class="pre">parmode=None,</span> <span class="pre">mpirun='mpirun',</span> <span class="pre">mpirun_args=['-np'],</span> <span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;,</span> <span class="pre">max_pos_diff=1.0,</span> <span class="pre">max_cell_diff=0.001,</span> <span class="pre">**vasp_args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.VaspClient" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#matscipy.socketcalc.QMClient" title="matscipy.socketcalc.QMClient"><code class="xref py py-class docutils literal notranslate"><span class="pre">QMClient</span></code></a></p>
<p>Subclass of Client for running VASP calculations.</p>
<p>Initial input files are written in POSCAR, INCAR, POTCAR and KPOINTS
formats, and subsequent communicatin is via sockets in REFTRAJ format.</p>
<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.VaspClient.postprocess">
<span class="sig-name descname"><span class="pre">postprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.VaspClient.postprocess" title="Permalink to this definition"></a></dt>
<dd><p>Post-process results of calculation.</p>
<p>May be overrriden in subclasses to e.g. reverse sort order
applied in preprocess().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.VaspClient.preprocess">
<span class="sig-name descname"><span class="pre">preprocess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_restart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.VaspClient.preprocess" title="Permalink to this definition"></a></dt>
<dd><p>Prepare client for a calculation.</p>
<p>Starts client if this is the first task for it, or schedules a
restart if new configuration is not compatible with the last
one submitted to the queue (see is_compatible() method).</p>
<p>Many be extended in subclasses to e.g. sort the atoms by
atomic number. If Atoms object needs to be changed, a copy
should be returned rather than updating it inplace.</p>
<p>Returns (at, first_time).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.socketcalc.VaspClient.write_input_files">
<span class="sig-name descname"><span class="pre">write_input_files</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.VaspClient.write_input_files" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.socketcalc.pack_atoms_to_reftraj_str">
<span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">pack_atoms_to_reftraj_str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.pack_atoms_to_reftraj_str" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.socketcalc.pack_atoms_to_xyz_str">
<span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">pack_atoms_to_xyz_str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.pack_atoms_to_xyz_str" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.socketcalc.pack_results_to_reftraj_output_str">
<span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">pack_results_to_reftraj_output_str</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">at</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.pack_results_to_reftraj_output_str" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.socketcalc.unpack_reftraj_output_str_to_results">
<span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">unpack_reftraj_output_str_to_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.unpack_reftraj_output_str_to_results" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.socketcalc.unpack_reftraj_str_to_atoms">
<span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">unpack_reftraj_str_to_atoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.unpack_reftraj_str_to_atoms" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.socketcalc.unpack_xyz_str_to_results">
<span class="sig-prename descclassname"><span class="pre">matscipy.socketcalc.</span></span><span class="sig-name descname"><span class="pre">unpack_xyz_str_to_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.socketcalc.unpack_xyz_str_to_results" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="matscipy-structure-identification-module">
<h2>matscipy.structure_identification module<a class="headerlink" href="#matscipy-structure-identification-module" title="Permalink to this heading"></a></h2>
</section>
<section id="module-matscipy.surface">
<span id="matscipy-surface-module"></span><h2>matscipy.surface module<a class="headerlink" href="#module-matscipy.surface" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matscipy.surface.MillerDirection">
<span class="sig-prename descclassname"><span class="pre">matscipy.surface.</span></span><span class="sig-name descname"><span class="pre">MillerDirection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerDirection" title="Permalink to this definition"></a></dt>
<dd><p>Special case of <a class="reference internal" href="#matscipy.surface.MillerIndex" title="matscipy.surface.MillerIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MillerIndex</span></code></a> with <code class="docutils literal notranslate"><span class="pre">type=&quot;direction&quot;</span></code> (the default)</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">matscipy.surface.</span></span><span class="sig-name descname"><span class="pre">MillerIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'direction'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
<p>Representation of a three of four index Miller direction or plane</p>
<p>A <a class="reference internal" href="#matscipy.surface.MillerIndex" title="matscipy.surface.MillerIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MillerIndex</span></code></a> can be constructed from vector or parsed from a string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">MillerIndex</span><span class="p">(</span><span class="s1">&#39;-211&#39;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">MillerIndex</span><span class="p">(</span><span class="s1">&#39;111&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;plane&#39;</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">x</span> <span class="c1"># prints &quot;[-211]&quot;</span>
<span class="nb">print</span> <span class="n">y</span> <span class="c1"># prints &quot;(111)&quot;, note round brackets denoting a plane</span>
<span class="nb">print</span> <span class="n">z</span><span class="o">.</span><span class="n">latex</span><span class="p">()</span>
<span class="k">assert</span><span class="p">(</span><span class="n">angle_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">angle_between</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="k">assert</span><span class="p">(</span><span class="n">angle_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.all_brackets">
<span class="sig-name descname"><span class="pre">all_brackets</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">['[',</span> <span class="pre">']',</span> <span class="pre">'&lt;',</span> <span class="pre">'&gt;',</span> <span class="pre">'(',</span> <span class="pre">')',</span> <span class="pre">'{',</span> <span class="pre">'}']</span></em><a class="headerlink" href="#matscipy.surface.MillerIndex.all_brackets" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.angle">
<span class="sig-name descname"><span class="pre">angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.angle" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.as3">
<span class="sig-name descname"><span class="pre">as3</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.as3" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.as4">
<span class="sig-name descname"><span class="pre">as4</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.as4" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.brackets">
<span class="sig-name descname"><span class="pre">brackets</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{'direction':</span> <span class="pre">'[]',</span> <span class="pre">'direction_family':</span> <span class="pre">'&lt;&gt;',</span> <span class="pre">'plane':</span> <span class="pre">'()',</span> <span class="pre">'plane_family':</span> <span class="pre">'{}'}</span></em><a class="headerlink" href="#matscipy.surface.MillerIndex.brackets" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.cosine">
<span class="sig-name descname"><span class="pre">cosine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.cosine" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.cross">
<span class="sig-name descname"><span class="pre">cross</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.cross" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.hat">
<span class="sig-name descname"><span class="pre">hat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.hat" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.latex">
<span class="sig-name descname"><span class="pre">latex</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.latex" title="Permalink to this definition"></a></dt>
<dd><p>Format this <a class="reference internal" href="#matscipy.surface.MillerIndex" title="matscipy.surface.MillerIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MillerIndex</span></code></a> as a LaTeX string</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.norm" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.normalised">
<span class="sig-name descname"><span class="pre">normalised</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.normalised" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.parse">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">parse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.parse" title="Permalink to this definition"></a></dt>
<dd><p>Parse a Miller index string</p>
<dl class="simple">
<dt>Negative indices can be denoted by:</dt><dd><ol class="arabic simple">
<li><p>leading minus sign, e.g. <code class="docutils literal notranslate"><span class="pre">[11-2]</span></code></p></li>
<li><p>trailing <code class="docutils literal notranslate"><span class="pre">b</span></code> (for ‘bar’), e.g. <code class="docutils literal notranslate"><span class="pre">112b</span></code></p></li>
<li><p>LaTeX <code class="docutils literal notranslate"><span class="pre">\bar{}</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">[11\bar{2}]</span></code> (which renders as <span class="math notranslate nohighlight">\([11\bar{2}]\)</span> in LaTeX)</p></li>
</ol>
</dd>
</dl>
<p>Leading or trailing brackets of various kinds are ignored.
i.e. <code class="docutils literal notranslate"><span class="pre">[001]</span></code>, <code class="docutils literal notranslate"><span class="pre">{001}</span></code>, <code class="docutils literal notranslate"><span class="pre">(001)</span></code>, <code class="docutils literal notranslate"><span class="pre">[001]</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;001&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">001</span></code> are all equivalent.</p>
<p>Returns an array of components (i,j,k) or (h,k,i,l)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.plane_spacing">
<span class="sig-name descname"><span class="pre">plane_spacing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.plane_spacing" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.simplified" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="matscipy.surface.MillerIndex.simplify">
<span class="sig-name descname"><span class="pre">simplify</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerIndex.simplify" title="Permalink to this definition"></a></dt>
<dd><p>Simplify by dividing through by greatest common denominator</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.surface.MillerPlane">
<span class="sig-prename descclassname"><span class="pre">matscipy.surface.</span></span><span class="sig-name descname"><span class="pre">MillerPlane</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.MillerPlane" title="Permalink to this definition"></a></dt>
<dd><p>Special case of <a class="reference internal" href="#matscipy.surface.MillerIndex" title="matscipy.surface.MillerIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MillerIndex</span></code></a> with <code class="docutils literal notranslate"><span class="pre">type=&quot;plane&quot;</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.surface.angle_between">
<span class="sig-prename descclassname"><span class="pre">matscipy.surface.</span></span><span class="sig-name descname"><span class="pre">angle_between</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.angle_between" title="Permalink to this definition"></a></dt>
<dd><p>Angle between crystallographic directions between a=[ijk] and b=[lmn], in radians.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.surface.gcd">
<span class="sig-prename descclassname"><span class="pre">matscipy.surface.</span></span><span class="sig-name descname"><span class="pre">gcd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.gcd" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the greatest common divisor of a and b</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.surface.make_unit_slab">
<span class="sig-prename descclassname"><span class="pre">matscipy.surface.</span></span><span class="sig-name descname"><span class="pre">make_unit_slab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unit_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.surface.make_unit_slab" title="Permalink to this definition"></a></dt>
<dd><p>General purpose unit slab creation routine</p>
<p>Only tested with cubic unit cells.</p>
<dl class="simple">
<dt>Code translated from quippy.structures.unit_slab()</dt><dd><p><a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Structures.f95">https://github.com/libAtoms/QUIP/blob/public/src/libAtoms/Structures.f95</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unit_cell</strong> (<em>Atoms</em>) – Atoms object containing primitive unit cell</p></li>
<li><p><strong>axes</strong> (<em>3x3 array</em>) – Miller indices of desired slab, as columns</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>slab</strong> – Output slab, with axes aligned with x, y, z.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Atoms</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-matscipy">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-matscipy" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="matscipy.has_parameter">
<span class="sig-prename descclassname"><span class="pre">matscipy.</span></span><span class="sig-name descname"><span class="pre">has_parameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.has_parameter" title="Permalink to this definition"></a></dt>
<dd><p>Test if a parameter has been provided in params.py.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Name of the parameter.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>value</strong> – Returns True if parameter exists.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="matscipy.parameter">
<span class="sig-prename descclassname"><span class="pre">matscipy.</span></span><span class="sig-name descname"><span class="pre">parameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logger=&lt;matscipy.logger.Logger</span> <span class="pre">object&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#matscipy.parameter" title="Permalink to this definition"></a></dt>
<dd><p>Read parameter from params.py control file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name of the parameter.</p></li>
<li><p><strong>default</strong> (<em>optional</em>) – Default value. Will be returned if parameter is not present.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Value of the parameter.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>value</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015, James Kermode, Lars Pastewka.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>